package com.theairebellion.zeus.db.service.fluent;

import com.theairebellion.zeus.db.query.DbQuery;
import com.theairebellion.zeus.db.query.QueryResponse;
import com.theairebellion.zeus.db.service.DatabaseService;
import com.theairebellion.zeus.db.service.fluent.mock.DummyEnum;
import com.theairebellion.zeus.validator.core.Assertion;
import com.theairebellion.zeus.validator.core.AssertionResult;
import com.theairebellion.zeus.framework.chain.FluentService;
import com.theairebellion.zeus.framework.quest.Quest;
import org.assertj.core.api.SoftAssertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.lang.reflect.Field;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;

import static org.mockito.Mockito.*;

public class DatabaseServiceFluentTest {

    private DatabaseService databaseService;
    private DatabaseServiceFluent fluent;
    private DbQuery query;
    private QueryResponse queryResponse;
    private Assertion<?> assertion;
    private List<AssertionResult<Object>> assertionResults;

    @BeforeEach
    void setUp() throws Exception {
        // Create a mock for the underlying database service.
        databaseService = mock(DatabaseService.class);
        // Instantiate the fluent service.
        fluent = new DatabaseServiceFluent(databaseService);
        // Now set the protected "quest" field in FluentService (declared as com.theairebellion.zeus.framework.quest.Quest)
        // to a real instance of Quest.
        Field questField = FluentService.class.getDeclaredField("quest");
        questField.setAccessible(true);
        questField.set(fluent, new Quest());  // use the actual Quest implementation

        query = mock(DbQuery.class);
        queryResponse = mock(QueryResponse.class);
        assertion = mock(Assertion.class);

        // Create a real instance of AssertionResult indicating success.
        // Our AssertionResult has a getter getPassed() generated by Lombok.
        AssertionResult<Object> ar = new AssertionResult<>(true, "Dummy validation", "expected", "actual", false);
        assertionResults = Collections.singletonList(ar);
    }

    @Test
    void testQuery() {
        when(databaseService.query(query)).thenReturn(queryResponse);
        // Stub query.enumImpl() to return our dummy enum value.
        doReturn(DummyEnum.VALUE).when(query).enumImpl();

        DatabaseServiceFluent result = fluent.query(query);
        // The fluent method should return itself (for chaining)
        assert fluent == result;
        verify(databaseService).query(query);
    }

    @Test
    void testQueryWithJsonPath() {
        String jsonPath = "$.data";
        when(databaseService.query(query, jsonPath, String.class)).thenReturn("resultString");
        doReturn(DummyEnum.VALUE).when(query).enumImpl();

        DatabaseServiceFluent result = fluent.query(query, jsonPath, String.class);
        assert fluent == result;
        verify(databaseService).query(query, jsonPath, String.class);
    }

    @Test
    void testValidateWithQueryResponseAndAssertions() {
        when(databaseService.validate(queryResponse, assertion)).thenReturn(assertionResults);
        DatabaseServiceFluent result = fluent.validate(queryResponse, assertion);
        assert fluent == result;
        verify(databaseService).validate(queryResponse, assertion);
    }

    @Test
    void testQueryAndValidate() {
        when(databaseService.query(query)).thenReturn(queryResponse);
        when(databaseService.validate(queryResponse, assertion)).thenReturn(assertionResults);
        doReturn(DummyEnum.VALUE).when(query).enumImpl();

        DatabaseServiceFluent result = fluent.queryAndValidate(query, assertion);
        assert fluent == result;
        verify(databaseService).query(query);
        verify(databaseService).validate(queryResponse, assertion);
    }

    @Test
    void testValidateRunnable() {
        Runnable runnable = () -> {
            // dummy validation logic
        };
        DatabaseServiceFluent result = fluent.validate(runnable);
        assert fluent == result;
    }

    @Test
    void testValidateConsumer() {
        Consumer<SoftAssertions> consumer = softAssertions -> {
            // dummy validation logic
        };
        DatabaseServiceFluent result = fluent.validate(consumer);
        assert fluent == result;
    }
}